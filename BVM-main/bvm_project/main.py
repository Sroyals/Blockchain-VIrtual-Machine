import argparse
from bvm.vm import BVM
from state.world_state import WorldState
from compilers.compiler import Compiler
from compilers.c_compiler import CCompiler
from compilers.java_compiler import JavaCompiler
import os

def main():
    # Set up argument parser
    parser = argparse.ArgumentParser(description='Blockchain Virtual Machine (BVM)')
    parser.add_argument('contract_path', help='Path to contract file (without extension)')
    parser.add_argument('address', default='contract1', help='Contract address identifier')
    parser.add_argument('gas_limit', type=int, default=500000, help='Maximum gas allowed')
    args = parser.parse_args()

    print(f"Starting BVM with contract '{args.address}'...")
    
    # Initialize world state and BVM
    world_state = WorldState(storage_file=f'{args.address}.json')
    vm = BVM(world_state)
    
    # Detect contract language and load source
    contract_source = None
    compiler = None
    
    # Detect contract language based on full filename
    if args.contract_path.endswith('.py'):
        # Python contract
        print("\nDetected Python contract")
        with open(args.contract_path, 'r') as f:
            contract_source = f.read()
            compiler = Compiler

    elif args.contract_path.endswith('.c'):
        # C contract
        print("\nDetected C contract")
        with open(args.contract_path, 'r') as f:
            contract_source = f.read()
            compiler = CCompiler

    elif args.contract_path.endswith('.java'):
        # Java contract
        print("\nDetected Java contract")
        with open(args.contract_path, 'r') as f:
            contract_source = f.read()
            compiler = JavaCompiler

    else:
        raise ValueError(
            "Unsupported file extension. "
            "Please use .py, .c, or .java"
        )

    # Compile contract
    print("Compiling contract...")
    bytecode, storage_map = compiler.compile(contract_source)
    
    print(f"\nGenerated bytecode: {bytecode.hex()}")
    print(f"Storage mapping: {storage_map}")

    # Deploy and execute
    world_state.set_contract_code(args.address, bytecode)
    
    print("\nExecuting contract...")
    result = vm.execute(bytecode, address=args.address, gas_limit=args.gas_limit)
    
    # Display results
    print("\nExecution Results:")
    print(f"Contract: {args.address}")
    print(f"Status: {'Success' if result['success'] else 'Failed'}")
    print(f"Gas used: {args.gas_limit - result['gas_remaining']}/{args.gas_limit}")
    
    if result['success']:
        print("Final and previous storage state: ")
        print( result['storage'])
    else:
        print(f"Error: {result.get('error', 'Unknown')}")
        if result.get('storage'):
            print("Partial storage state: ")
            print(result['storage'])

if __name__ == "__main__":
    main()
